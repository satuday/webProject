    <div class="post">
        <div class="post-title">
            <h2>
                Tree Structures

            </h2>
        </div>
        <div class="post-body" style="font-size: 14px; font-family: 'Helvetica', 'Segoe UI', 'Segoe WP', Arial, sans-serif;">
           <p>Tree structures are quite common in computer science. They can represent a sorted collection of numbers or names, or a series of decisions that need to be made. Like graphs (described in another section), trees are made up of nodes and directed arcs. Nodes represent some value and arcs point from one node to another. Trees are in many ways like graphs with restrictions on how the arcs are arranged.</p>
            <p>In computer science trees grow upside down. The root is at the top and the leaves are at the bottom. Below is an example of a tree that is being used to hold some integers in a particular order:</p>
            <p><img src="http://holowczak.com/wp-content/uploads/tree_example.gif" alt="Tree graph example"></p>
            <p>The nodes in this tree represent integers. In this case, the integers 1, 3, 4, 5, 7, 8 and 10 have been used. The&nbsp;<em>root node</em>&nbsp;is labeled as “5″ and appears at the top of the tree. Several <em>interior nodes</em>&nbsp;(nodes that are neither root nor leaves) labeled 3 and 8 appear in the middle of the tree. Finally,&nbsp;<em>leaf nodes</em>&nbsp;with labels 1, 4, 7 and 10 appear at the bottom of the tree.</p>
            <p>A&nbsp;<em>Parent node</em>&nbsp;is one that has at least one node below it. In the above tree, node 3 is a parent and its&nbsp;<em>Child nodes</em>&nbsp;are 1 and 4. (Can you find the other 2 parent nodes in the graph?) Child nodes with a common parent are called&nbsp;<em>sibling nodes</em>. In the example, nodes 1 and 4 are siblings. As a rule, child nodes in a tree may only have one parent. (Can you find the other siblings in the graph?)</p>
            <p>Another feature of a tree is the number of levels of depth. In the example, the tree is 3 levels deep. If the number of children is the same for all parent nodes, we say that the tree is <em>balanced</em>. In the above example, all nodes (except the leaf nodes) have 2 children so the tree is balanced.</p>
            <p>A tree with 2 children per parent is also called a&nbsp;<em>binary</em>&nbsp;tree. Looking at the above example, one can see that for each parent node, one of its children has a value less than the parent, and the other child has a value greater than that of the parent. For example, the parent node 5 has a&nbsp;<em>left child</em>&nbsp;with value 3 (less than its parent) and a&nbsp;<em>right child</em>&nbsp;with value 8 (greater than its parent).</p>
            <p>Trees can be used to assist us in sorting and searching for data of interest. For example, suppose we have the following set of data:</p>
            <table border="" cellpadding="5">
<tbody>
<tr>
<th>Name</th>
<th>Age</th>
</tr>
<tr>
<td>Bailey</td>
<td>41</td>
</tr>
<tr>
<td>Brown</td>
<td>27</td>
</tr>
<tr>
<td>Green</td>
<td>21</td>
</tr>
<tr>
<td>Jones</td>
<td>38</td>
</tr>
<tr>
<td>Smith</td>
<td>35</td>
</tr>
<tr>
<td>Taner</td>
<td>63</td>
</tr>
<tr>
<td>Vespa</td>
<td>31</td>
</tr>
</tbody>
</table>

            <p>We would like to be able to store this data in such a way that improves how we can search for a person later on. We can construct a binary tree to store the names and ages in the following fashion. First, find the&nbsp;<em>median</em>&nbsp;value (the value that appears closest to the middle) of the list and make that the root node. In this example, “Jones” appears to be in the middle of the list so we can make Jones the root node.</p>
            <p>Next, look at the all of the values that come before Jones in the list: Bailey, Brown and Green. Choose the median of these three and make it the left child of Jones. Repeat this process with the bottom half of the list (after Jones) to establish the right child of Jones.</p>
            <p>Finally, repeat the process again for the next level by taking Brown and Taner each as parents. The resulting tree looks like the following:</p>
            <p><img src="http://holowczak.com/wp-content/uploads/tree_example2.gif" alt="Binary tree search example"></p>
            <p>To search such a tree, start at the root node and:</p>
            <ol>
<li>Compare the target value (what is being searched for) with the root node.</li>
<li>If the target value matches the current node, the search is over</li>
<li>If the target value is less than the current node’s value, move to the current node’s left child and go back to step 2.</li>
<li>If the target value is greater than the current node’s value, move to the current node’s right child and go back to step 2.</li>
<li>If we reach a leaf node and the target value is not found, then it is not in the tree.</li>
</ol>
            <p>As an example, assume we are searching for “Vespa”. Starting with the root node, we compare Vespa with Jones. Since Vespa comes after Jones in the alphabet (Vespa is greater than Jones) we move to Jones’ right child. At this node, we compare Vespa with Taner and see that since Vespa is greater than Taner, we move to Taner’s right child node. Finally, we find the target node.</p>
            <p>Notice that if we have to search through the list (starting from the first entry), it would have taken us 7 steps to finally locate Vespa. On average, we would expect to find what we are looking for in the list after about 3 or 4 steps. With the binary tree, we will never have to use more than 3 steps.</p>
            <p>We can generalize this reasoning with the following points:</p>
            <ul>
<li>Searching in a list (linear search) of&nbsp;<em>n</em>&nbsp;items will require on average&nbsp;<em>n / 2</em>&nbsp;steps.</li>
<li>Searching the same list represented as a binary tree will require no more than&nbsp;log<span style="font-size:50%;vertical-align:sub;">2</span>n &nbsp;steps.</li>
</ul>
            <p>Here is a comparison:</p>
            <table border="" cellpadding="5">
<tbody>
<tr>
<th>Number of Items&nbsp;<em>n</em></th>
<th>Linear Search</th>
<th>Binary Search</th>
</tr>
<tr>
<td>4</td>
<td>4/2 = 2</td>
<td>log<span style="font-size:50%;vertical-align:sub;">2</span>&nbsp;4 = 2</td>
</tr>
<tr>
<td>8</td>
<td>8/2 = 4</td>
<td>log<span style="font-size:50%;vertical-align:sub;">2</span>&nbsp;8 = 3</td>
</tr>
<tr>
<td>16</td>
<td>16/2 = 8</td>
<td>log<span style="font-size:50%;vertical-align:sub;">2</span>&nbsp;16 = 4</td>
</tr>
<tr>
<td>32</td>
<td>32/2 = 16</td>
<td>log<span style="font-size:50%;vertical-align:sub;">2</span>&nbsp;32 = 5</td>
</tr>
<tr>
<td>64</td>
<td>64/2 = 32</td>
<td>log<span style="font-size:50%;vertical-align:sub;">2</span>&nbsp;64 = 6</td>
</tr>
<tr>
<td>128</td>
<td>128/2 = 64</td>
<td>log<span style="font-size:50%;vertical-align:sub;">2</span>&nbsp;128 = 7</td>
</tr>
</tbody>
</table>
            <p>It is clear from the comparison that the binary tree representation can cut down significantly on the number of steps.</p>

        </div>
    </div>   
